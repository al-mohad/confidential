/// Code generation for obfuscated literals.
library;

import 'dart:convert';
import 'dart:math';
import 'dart:typed_data';

import '../configuration/configuration.dart';
class CodeGenerator {
  final ConfidentialConfiguration config;
  final Random _random = Random();
  
  CodeGenerator(this.config);
  
  /// Generates the complete Dart source code.
  String generate() {
    final buffer = StringBuffer();
    
    // Generate file header
    _generateHeader(buffer);
    
    // Group secrets by namespace
    final namespaceGroups = _groupSecretsByNamespace();
    
    // Generate code for each namespace
    for (final entry in namespaceGroups.entries) {
      final namespace = entry.key;
      final secrets = entry.value;
      
      _generateNamespace(buffer, namespace, secrets);
    }
    
    return buffer.toString();
  }
  
  void _generateHeader(StringBuffer buffer) {
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by dart-confidential');
    buffer.writeln('');
    
    if (config.internalImport) {
      buffer.writeln("import 'package:confidential/confidential.dart' show Secret, ObfuscatedValue;");
    } else {
      buffer.writeln("import 'package:confidential/confidential.dart';");
    }
    
    buffer.writeln("import 'dart:typed_data';");
    buffer.writeln("import 'dart:convert';");
    buffer.writeln('');
  }
  
  Map<NamespaceDefinition, List<SecretDefinition>> _groupSecretsByNamespace() {
    final groups = <NamespaceDefinition, List<SecretDefinition>>{};
    
    for (final secret in config.secrets) {
      final namespaceStr = secret.getNamespace(config.defaultNamespace);
      final namespace = NamespaceDefinition.parse(namespaceStr);
      
      groups.putIfAbsent(namespace, () => []).add(secret);
    }
    
    return groups;
  }
  
  void _generateNamespace(StringBuffer buffer, NamespaceDefinition namespace, List<SecretDefinition> secrets) {
    // Generate imports for extensions
    if (namespace.isExtension && namespace.module != null) {
      buffer.writeln("import 'package:${namespace.module}/${namespace.module}.dart';");
      buffer.writeln('');
    }
    
    // Generate namespace declaration
    if (namespace.isExtension) {
      if (namespace.module != null) {
        buffer.writeln('extension ${namespace.name}Confidential on ${namespace.module}.${namespace.name} {');
      } else {
        buffer.writeln('extension ${namespace.name}Confidential on ${namespace.name} {');
      }
    } else {
      final accessModifier = config.defaultAccessModifier == 'internal' ? '' : '${config.defaultAccessModifier} ';
      buffer.writeln('${accessModifier}class ${namespace.name} {');
    }
    
    buffer.writeln('');
    
    // Generate secrets
    for (final secret in secrets) {
      _generateSecret(buffer, secret);
      buffer.writeln('');
    }
    
    // Generate deobfuscation function
    _generateDeobfuscationFunction(buffer);
    
    buffer.writeln('}');
    buffer.writeln('');
  }
  
  void _generateSecret(StringBuffer buffer, SecretDefinition secret) {
    final accessModifier = secret.getAccessModifier(config.defaultAccessModifier);
    final dartType = secret.dartType;
    final nonce = _generateNonce();
    
    // Obfuscate the secret value
    final obfuscatedData = _obfuscateValue(secret.value, nonce);
    
    // Generate the property
    if (config.experimentalMode) {
      // Use macro-style annotation (experimental)
      buffer.writeln('  @Obfuscated<$dartType>(_deobfuscateData)');
    }
    
    final staticKeyword = accessModifier == 'internal' ? 'static' : '$accessModifier static';
    
    if (config.experimentalMode) {
      buffer.writeln('  $staticKeyword var ${secret.name} = Secret(');
    } else {
      buffer.writeln('  $staticKeyword final ${secret.name} = ObfuscatedValue<$dartType>(');
      buffer.writeln('    Secret(');
    }
    
    buffer.writeln('      data: Uint8List.fromList([${obfuscatedData.map((b) => '0x${b.toRadixString(16).padLeft(2, '0')}').join(', ')}]),');
    buffer.writeln('      nonce: $nonce,');
    
    if (config.experimentalMode) {
      buffer.writeln('    );');
    } else {
      buffer.writeln('    ),');
      buffer.writeln('    _deobfuscateData,');
      buffer.writeln('  );');
    }
  }
  
  void _generateDeobfuscationFunction(StringBuffer buffer) {
    buffer.writeln('  static T _deobfuscateData<T>(Uint8List data, int nonce) {');
    buffer.writeln('    try {');
    
    // Generate the deobfuscation chain
    final obfuscation = config.createObfuscation();
    buffer.writeln('      var result = data;');
    
    // Apply deobfuscation steps in reverse order
    for (final step in obfuscation.steps.reversed) {
      if (step.name.contains('aes') && step.name.contains('gcm')) {
        buffer.writeln('      result = _deobfuscateAesGcm(result, nonce, ${_getKeySize(step.name)});');
      } else if (step.name == 'chacha20-poly1305') {
        buffer.writeln('      result = _deobfuscateChaCha20Poly1305(result, nonce);');
      } else if (step.name == 'shuffle') {
        buffer.writeln('      result = _deobfuscateShuffle(result, nonce);');
      } else if (step.name == 'xor') {
        buffer.writeln('      result = _deobfuscateXor(result, nonce);');
      } else if (_isCompressionAlgorithm(step.name)) {
        buffer.writeln('      result = _deobfuscateCompression(result, nonce, \'${step.name}\');');
      }
    }
    
    buffer.writeln('      return _deserializeValue<T>(result);');
    buffer.writeln('    } catch (e) {');
    buffer.writeln('      throw Exception(\'Deobfuscation failed: \$e\');');
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln('');
    
    // Generate helper methods
    _generateDeobfuscationHelpers(buffer);
  }
  
  void _generateDeobfuscationHelpers(StringBuffer buffer) {
    buffer.writeln('  static T _deserializeValue<T>(Uint8List data) {');
    buffer.writeln('    final json = utf8.decode(data);');
    buffer.writeln('    final decoded = jsonDecode(json);');
    buffer.writeln('    return decoded as T;');
    buffer.writeln('  }');
    buffer.writeln('');
    
    // Add placeholder implementations for deobfuscation methods
    buffer.writeln('  static Uint8List _deobfuscateAesGcm(Uint8List data, int nonce, int keySize) {');
    buffer.writeln('    // Implementation would use the actual AES-GCM decryption');
    buffer.writeln('    throw UnimplementedError(\'AES-GCM deobfuscation not implemented in generated code\');');
    buffer.writeln('  }');
    buffer.writeln('');
    
    buffer.writeln('  static Uint8List _deobfuscateChaCha20Poly1305(Uint8List data, int nonce) {');
    buffer.writeln('    // Implementation would use the actual ChaCha20-Poly1305 decryption');
    buffer.writeln('    throw UnimplementedError(\'ChaCha20-Poly1305 deobfuscation not implemented in generated code\');');
    buffer.writeln('  }');
    buffer.writeln('');
    
    buffer.writeln('  static Uint8List _deobfuscateShuffle(Uint8List data, int nonce) {');
    buffer.writeln('    // Implementation would use the actual shuffle deobfuscation');
    buffer.writeln('    throw UnimplementedError(\'Shuffle deobfuscation not implemented in generated code\');');
    buffer.writeln('  }');
    buffer.writeln('');
    
    buffer.writeln('  static Uint8List _deobfuscateXor(Uint8List data, int nonce) {');
    buffer.writeln('    // Implementation would use the actual XOR deobfuscation');
    buffer.writeln('    throw UnimplementedError(\'XOR deobfuscation not implemented in generated code\');');
    buffer.writeln('  }');
    buffer.writeln('');
    
    buffer.writeln('  static Uint8List _deobfuscateCompression(Uint8List data, int nonce, String algorithm) {');
    buffer.writeln('    // Implementation would use the actual compression deobfuscation');
    buffer.writeln('    throw UnimplementedError(\'Compression deobfuscation not implemented in generated code\');');
    buffer.writeln('  }');
  }
  
  Uint8List _obfuscateValue(dynamic value, int nonce) {
    // Serialize the value to JSON
    final json = jsonEncode(value);
    final data = Uint8List.fromList(utf8.encode(json));
    
    // Apply obfuscation
    final obfuscation = config.createObfuscation();
    return obfuscation.obfuscate(data, nonce);
  }
  
  int _generateNonce() {
    return _random.nextInt(1 << 32);
  }
  
  int _getKeySize(String algorithmName) {
    if (algorithmName.contains('128')) return 128;
    if (algorithmName.contains('192')) return 192;
    if (algorithmName.contains('256')) return 256;
    return 256; // Default
  }
  
  bool _isCompressionAlgorithm(String name) {
    return ['zlib', 'gzip', 'bzip2', 'lz4', 'lzfse', 'lzma'].contains(name);
  }
}
